"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeMessageStanza = void 0;
const boom_1 = require("@hapi/boom");
const WAProto_1 = require("../../WAProto");
const WABinary_1 = require("../WABinary");
const generics_1 = require("./generics");
const signal_1 = require("./signal");
const NO_MESSAGE_FOUND_ERROR_TEXT = "Message absent from node";
const decodeMessageStanza = (stanza, auth) => {
    var _a, _b, _c, _d, _e;
    let msgType;
    let chatId;
    let author;
    const meUser = (_a = (0, WABinary_1.jidDecode)(auth.creds.me.id)) === null || _a === void 0 ? void 0 : _a.user;
    const senderPn = stanza.attrs.sender_lid
        ? stanza.attrs.from
        : stanza.attrs.sender_pn;
    const senderLid = stanza.attrs.sender_pn
        ? stanza.attrs.from
        : stanza.attrs.sender_lid;
    const participantPn = (0, WABinary_1.isJidUser)(stanza.attrs.participant)
        ? stanza.attrs.participant
        : stanza.attrs.participant_pn;
    const participantLid = (0, WABinary_1.isLidUser)(stanza.attrs.participant)
        ? stanza.attrs.participant
        : stanza.attrs.participant_lid;
    const isGroup = (0, WABinary_1.isJidGroup)(stanza.attrs.from);
    const fromJidUser = (_b = (0, WABinary_1.jidDecode)(senderPn)) === null || _b === void 0 ? void 0 : _b.user;
    const fromDevice = (_c = (0, WABinary_1.jidDecode)(stanza.attrs.from)) === null || _c === void 0 ? void 0 : _c.device;
    const participantJidUser = (_d = (0, WABinary_1.jidDecode)(participantPn)) === null || _d === void 0 ? void 0 : _d.user;
    const participantDevice = (_e = (0, WABinary_1.jidDecode)(stanza.attrs.participant)) === null || _e === void 0 ? void 0 : _e.device;
    const participantFullJid = participantJidUser
        ? (0, WABinary_1.jidEncode)(participantJidUser, "s.whatsapp.net", participantDevice)
        : undefined;
    const fromFullJid = !isGroup && fromJidUser
        ? (0, WABinary_1.jidEncode)(fromJidUser, "s.whatsapp.net", fromDevice)
        : undefined;
    const msgId = stanza.attrs.id;
    const from = fromFullJid || stanza.attrs.from;
    const participant = participantFullJid || stanza.attrs.participant;
    const recipient = stanza.attrs.peer_recipient_pn || stanza.attrs.recipient;
    const recipientLid = (0, WABinary_1.isLidUser)(stanza.attrs.recipient)
        ? stanza.attrs.recipient
        : stanza.attrs.peer_recipient_lid;
    const isMe = (jid) => (0, WABinary_1.areJidsSameUser)(jid, auth.creds.me.id);
    const isMeLid = (jid) => (0, WABinary_1.areJidsSameUser)(jid, auth.creds.me.lid);
    if ((0, WABinary_1.isJidUser)(from) || (0, WABinary_1.isLidUser)(from)) {
        if (recipient && !(0, WABinary_1.isJidMetaAI)(recipient)) {
            if (!isMe(from) && !isMeLid(from)) {
                throw new boom_1.Boom("recipient present, but msg not from me", {
                    data: stanza
                });
            }
            chatId = recipient;
        }
        else {
            chatId = from;
        }
        msgType = "chat";
        author = from;
    }
    else if ((0, WABinary_1.isJidGroup)(from)) {
        if (!participant) {
            throw new boom_1.Boom("No participant in group message");
        }
        msgType = "group";
        chatId = from;
        author = isMeLid(participant)
            ? (0, WABinary_1.jidEncode)(meUser, "s.whatsapp.net", participantDevice)
            : participant;
    }
    else if ((0, WABinary_1.isJidBroadcast)(from)) {
        if (!participant) {
            throw new boom_1.Boom("No participant in group message");
        }
        const isParticipantMe = isMe(participant) || isMeLid(participant);
        if ((0, WABinary_1.isJidStatusBroadcast)(from)) {
            msgType = isParticipantMe ? "direct_peer_status" : "other_status";
        }
        else {
            msgType = isParticipantMe ? "peer_broadcast" : "other_broadcast";
        }
        chatId = from;
        author = participant;
    }
    else if ((0, WABinary_1.isJidNewsletter)(from)) {
        msgType = "newsletter";
        chatId = from;
        author = from;
    }
    else {
        throw new boom_1.Boom("Unknown message type", { data: stanza });
    }
    const sender = msgType === "chat" ? author : chatId;
    const fromMe = ((0, WABinary_1.isLidUser)(from) || (0, WABinary_1.isLidUser)(participant) ? isMeLid : isMe)(stanza.attrs.participant || stanza.attrs.from);
    const pushname = stanza.attrs.notify;
    const key = {
        remoteJid: chatId,
        fromMe,
        id: msgId,
        senderLid,
        senderPn,
        participant,
        participantPn,
        participantLid,
        recipientLid
    };
    const fullMessage = {
        key,
        category: stanza.attrs.category,
        messageTimestamp: +stanza.attrs.t,
        pushName: pushname
    };
    if (key.fromMe) {
        fullMessage.status = WAProto_1.proto.WebMessageInfo.Status.SERVER_ACK;
    }
    return {
        fullMessage,
        category: stanza.attrs.category,
        author,
        decryptionTask: (async () => {
            var _a, _b;
            let decryptables = 0;
            if (Array.isArray(stanza.content)) {
                for (const { tag, attrs, content } of stanza.content) {
                    if (tag === "unavailable" && attrs.type === "view_once") {
                        fullMessage.key.isViewOnce = true;
                    }
                    if (tag === "verified_name" && content instanceof Uint8Array) {
                        const cert = WAProto_1.proto.VerifiedNameCertificate.decode(content);
                        const details = WAProto_1.proto.VerifiedNameCertificate.Details.decode(cert.details);
                        fullMessage.verifiedBizName = details.verifiedName;
                    }
                    if (attrs.count && tag === "enc") {
                        fullMessage.retryCount = Number(attrs.count);
                    }
                    if (tag !== "enc" && tag !== "plaintext") {
                        continue;
                    }
                    if (!(content instanceof Uint8Array)) {
                        continue;
                    }
                    decryptables += 1;
                    let msgBuffer;
                    try {
                        const e2eType = tag === "plaintext" ? "plaintext" : attrs.type;
                        switch (e2eType) {
                            case "skmsg":
                                msgBuffer = await (0, signal_1.decryptGroupSignalProto)(sender, author, content, auth);
                                break;
                            case "pkmsg":
                            case "msg":
                                const user = (0, WABinary_1.isJidUser)(sender) ? sender : author;
                                msgBuffer = await (0, signal_1.decryptSignalProto)(user, e2eType, content, auth);
                                break;
                            case "msmsg":
                                return; // ignore meta IA messages
                            case "plaintext":
                                msgBuffer = content;
                                break;
                            default:
                                throw new Error(`Unknown e2e type: ${e2eType}`);
                        }
                        let msg = WAProto_1.proto.Message.decode(e2eType !== "plaintext" ? (0, generics_1.unpadRandomMax16)(msgBuffer) : msgBuffer);
                        msg = ((_a = msg.deviceSentMessage) === null || _a === void 0 ? void 0 : _a.message) || msg;
                        if (msg.senderKeyDistributionMessage) {
                            await (0, signal_1.processSenderKeyMessage)(author, msg.senderKeyDistributionMessage, auth);
                        }
                        if (fullMessage.message) {
                            Object.assign(fullMessage.message, msg);
                        }
                        else {
                            fullMessage.message = msg;
                        }
                    }
                    catch (error) {
                        fullMessage.messageStubType =
                            WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT;
                        fullMessage.messageStubParameters = [error.message];
                    }
                }
            }
            // if nothing was found to decrypt
            if (!decryptables && !((_b = fullMessage.key) === null || _b === void 0 ? void 0 : _b.isViewOnce)) {
                fullMessage.messageStubType = WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT;
                fullMessage.messageStubParameters = [NO_MESSAGE_FOUND_ERROR_TEXT];
            }
        })()
    };
};
exports.decodeMessageStanza = decodeMessageStanza;
