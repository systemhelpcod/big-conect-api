"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeMessagesSocket = void 0;
const boom_1 = require("@hapi/boom");
const node_cache_1 = __importDefault(require("node-cache"));
const WAProto_1 = require("../../WAProto");
const Defaults_1 = require("../Defaults");
const Utils_1 = require("../Utils");
const link_preview_1 = require("../Utils/link-preview");
const WABinary_1 = require("../WABinary");
const groups_1 = require("./groups");
const makeMessagesSocket = (config) => {
    const { logger, linkPreviewImageThumbnailWidth, generateHighQualityLinkPreview } = config;
    const sock = (0, groups_1.makeGroupsSocket)(config);
    const { ev, authState, upsertMessage, query, fetchPrivacySettings, generateMessageTag, sendNode, groupMetadata, groupToggleEphemeral } = sock;
    const userDevicesCache = config.userDevicesCache ||
        new node_cache_1.default({
            stdTTL: 300,
            useClones: false
        });
    const groupMetadataCache = config.groupMetadataCache;
    let mediaConn;
    const refreshMediaConn = async (forceGet = false) => {
        const media = await mediaConn;
        if (!media ||
            forceGet ||
            new Date().getTime() - media.fetchDate.getTime() > media.ttl * 1000) {
            mediaConn = (async () => {
                const result = await query({
                    tag: "iq",
                    attrs: {
                        type: "set",
                        xmlns: "w:m",
                        to: WABinary_1.S_WHATSAPP_NET
                    },
                    content: [{ tag: "media_conn", attrs: {} }]
                });
                const mediaConnNode = (0, WABinary_1.getBinaryNodeChild)(result, "media_conn");
                const node = {
                    hosts: (0, WABinary_1.getBinaryNodeChildren)(mediaConnNode, "host").map(item => item.attrs),
                    auth: mediaConnNode.attrs.auth,
                    ttl: +mediaConnNode.attrs.ttl,
                    fetchDate: new Date()
                };
                logger.debug("fetched media conn");
                return node;
            })();
        }
        return mediaConn;
    };
    /**
     * generic send receipt function
     * used for receipts of phone call, read, delivery etc.
     * */
    const sendReceipt = async (jid, participant, messageIds, type) => {
        const node = {
            tag: "receipt",
            attrs: {
                id: messageIds[0]
            }
        };
        const isReadReceipt = type === "read" || type === "read-self";
        if (isReadReceipt) {
            node.attrs.t = (0, Utils_1.unixTimestampSeconds)().toString();
        }
        if (type === "sender" && (0, WABinary_1.isJidUser)(jid)) {
            node.attrs.recipient = jid;
            node.attrs.to = participant;
        }
        else {
            node.attrs.to = jid;
            if (participant) {
                node.attrs.participant = participant;
            }
        }
        if (type) {
            node.attrs.type = type;
        }
        const remainingMessageIds = messageIds.slice(1);
        if (remainingMessageIds.length) {
            node.content = [
                {
                    tag: "list",
                    attrs: {},
                    content: remainingMessageIds.map(id => ({
                        tag: "item",
                        attrs: { id }
                    }))
                }
            ];
        }
        logger.debug({ attrs: node.attrs, messageIds }, "sending receipt for messages");
        await sendNode(node);
    };
    /** Correctly bulk send receipts to multiple chats, participants */
    const sendReceipts = async (keys, type) => {
        const recps = (0, Utils_1.aggregateMessageKeysNotFromMe)(keys);
        for (const { jid, participant, messageIds } of recps) {
            await sendReceipt(jid, participant, messageIds, type);
        }
    };
    /** Bulk read messages. Keys can be from different chats & participants */
    const readMessages = async (keys) => {
        const privacySettings = await fetchPrivacySettings();
        // based on privacy settings, we have to change the read type
        const readType = privacySettings.readreceipts === "all" ? "read" : "read-self";
        await sendReceipts(keys, readType);
    };
    /** Fetch all the devices we've to send a message to */
    const getUSyncDevices = async (jids, useCache, ignoreZeroDevices) => {
        var _a;
        const deviceResults = [];
        if (!useCache) {
            logger.debug("not using cache for devices");
        }
        const users = [];
        jids = Array.from(new Set(jids));
        for (let jid of jids) {
            const user = (_a = (0, WABinary_1.jidDecode)(jid)) === null || _a === void 0 ? void 0 : _a.user;
            jid = (0, WABinary_1.jidNormalizedUser)(jid);
            if (userDevicesCache.has(user) && useCache) {
                const devices = userDevicesCache.get(user);
                deviceResults.push(...devices);
                logger.trace({ user }, "using cache for devices");
            }
            else {
                users.push({ tag: "user", attrs: { jid } });
            }
        }
        const iq = {
            tag: "iq",
            attrs: {
                to: WABinary_1.S_WHATSAPP_NET,
                type: "get",
                xmlns: "usync"
            },
            content: [
                {
                    tag: "usync",
                    attrs: {
                        sid: generateMessageTag(),
                        mode: "query",
                        last: "true",
                        index: "0",
                        context: "message"
                    },
                    content: [
                        {
                            tag: "query",
                            attrs: {},
                            content: [
                                {
                                    tag: "devices",
                                    attrs: { version: "2" }
                                }
                            ]
                        },
                        { tag: "list", attrs: {}, content: users }
                    ]
                }
            ]
        };
        const result = await query(iq);
        const extracted = (0, Utils_1.extractDeviceJids)(result, authState.creds.me.id, ignoreZeroDevices);
        const deviceMap = {};
        for (const item of extracted) {
            deviceMap[item.user] = deviceMap[item.user] || [];
            deviceMap[item.user].push(item);
            deviceResults.push(item);
        }
        for (const key in deviceMap) {
            userDevicesCache.set(key, deviceMap[key]);
        }
        return deviceResults;
    };
    const assertSessions = async (jids, force) => {
        let didFetchNewSession = false;
        let jidsRequiringFetch = [];
        if (force) {
            jidsRequiringFetch = jids;
        }
        else {
            const addrs = jids.map(jid => (0, Utils_1.jidToSignalProtocolAddress)(jid).toString());
            const sessions = await authState.keys.get("session", addrs);
            for (const jid of jids) {
                const signalId = (0, Utils_1.jidToSignalProtocolAddress)(jid).toString();
                if (!sessions[signalId]) {
                    jidsRequiringFetch.push(jid);
                }
            }
        }
        if (jidsRequiringFetch.length) {
            logger.debug({ jidsRequiringFetch }, "fetching sessions");
            const result = await query({
                tag: "iq",
                attrs: {
                    xmlns: "encrypt",
                    type: "get",
                    to: WABinary_1.S_WHATSAPP_NET
                },
                content: [
                    {
                        tag: "key",
                        attrs: {},
                        content: jidsRequiringFetch.map(jid => ({
                            tag: "user",
                            attrs: { jid }
                        }))
                    }
                ]
            });
            await (0, Utils_1.parseAndInjectE2ESessions)(result, authState);
            didFetchNewSession = true;
        }
        return didFetchNewSession;
    };
    const sendPeerDataOperationMessage = async (pdoMessage) => {
        var _a;
        if (!((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id)) {
            throw new boom_1.Boom("Not authenticated");
        }
        const protocolMessage = {
            protocolMessage: {
                peerDataOperationRequestMessage: pdoMessage,
                type: WAProto_1.proto.Message.ProtocolMessage.Type
                    .PEER_DATA_OPERATION_REQUEST_MESSAGE
            }
        };
        const meJid = (0, WABinary_1.jidNormalizedUser)(authState.creds.me.id);
        const msgId = await relayMessage(meJid, protocolMessage, {
            additionalAttributes: {
                category: "peer",
                push_priority: "high_force"
            }
        });
        return msgId;
    };
    const createParticipantNodes = async (jids, bytes, extraAttrs) => {
        let shouldIncludeDeviceIdentity = false;
        const nodes = await Promise.all(jids.map(async (jid) => {
            const { type, ciphertext } = await (0, Utils_1.encryptSignalProto)(jid, bytes, authState);
            if (type === "pkmsg") {
                shouldIncludeDeviceIdentity = true;
            }
            const node = {
                tag: "to",
                attrs: { jid },
                content: [
                    {
                        tag: "enc",
                        attrs: {
                            v: "2",
                            type,
                            ...(extraAttrs || {})
                        },
                        content: ciphertext
                    }
                ]
            };
            return node;
        }));
        return { nodes, shouldIncludeDeviceIdentity };
    };
    const createButtonNode = (message) => {
        var _a;
        if (message.listMessage) {
            return [
                {
                    tag: "list",
                    attrs: { type: "product_list", v: "2" }
                }
            ];
        }
        if (message.buttonsMessage ||
            ((_a = message.interactiveMessage) === null || _a === void 0 ? void 0 : _a.nativeFlowMessage)) {
            return [
                {
                    tag: "interactive",
                    attrs: { type: "native_flow", v: "1" },
                    content: [{ tag: "native_flow", attrs: { v: "9", name: "mixed" } }]
                }
            ];
        }
        return null;
    };
    const relayMessage = async (jid, message, { messageId: msgId, participant, additionalAttributes, useUserDevicesCache, statusJidList }) => {
        var _a;
        const meId = authState.creds.me.id;
        const isRetryResend = Boolean(participant === null || participant === void 0 ? void 0 : participant.jid);
        let shouldIncludeDeviceIdentity = isRetryResend;
        const isGroup = (0, WABinary_1.isJidGroup)(jid);
        const isStatus = (0, WABinary_1.isJidStatusBroadcast)(jid);
        const isGroupOrStatus = isGroup || isStatus;
        msgId = msgId || (0, Utils_1.generateMessageIDV2)((_a = sock.user) === null || _a === void 0 ? void 0 : _a.id);
        useUserDevicesCache = useUserDevicesCache !== false;
        const destinationJid = isStatus ? "status@broadcast" : jid;
        const participants = [];
        const binaryNodeContent = [];
        const devices = [];
        const encodedMsg = (0, Utils_1.encodeWAMessage)(message);
        await authState.keys.transaction(async () => {
            var _a, _b, _c, _d, _e;
            if (isGroupOrStatus && !isRetryResend) {
                const [groupData, senderKeyMap] = await Promise.all([
                    (async () => {
                        let groupData = groupMetadataCache === null || groupMetadataCache === void 0 ? void 0 : groupMetadataCache.get(jid);
                        if (groupData && Array.isArray(groupData === null || groupData === void 0 ? void 0 : groupData.participants)) {
                            logger.trace({ jid, participants: groupData.participants.length }, "using cached group metadata");
                        }
                        if (!groupData && !isStatus) {
                            groupData = await groupMetadata(jid);
                            groupMetadataCache === null || groupMetadataCache === void 0 ? void 0 : groupMetadataCache.set(jid, groupData);
                        }
                        return groupData;
                    })(),
                    (async () => {
                        const result = await authState.keys.get("sender-key-memory", [jid]);
                        return result[jid] || {};
                    })()
                ]);
                const participantsList = groupData
                    ? groupData.participants.map(p => p.id)
                    : [];
                if (groupData === null || groupData === void 0 ? void 0 : groupData.ephemeralDuration) {
                    additionalAttributes = {
                        ...additionalAttributes,
                        expiration: groupData.ephemeralDuration.toString()
                    };
                }
                if (isStatus && statusJidList) {
                    participantsList.push(...statusJidList);
                }
                const additionalDevices = await getUSyncDevices(participantsList, !!useUserDevicesCache, false);
                devices.push(...additionalDevices);
                if (isGroup) {
                    additionalAttributes = {
                        ...additionalAttributes,
                        addressing_mode: (groupData === null || groupData === void 0 ? void 0 : groupData.addressingMode) || "pn"
                    };
                }
                const { ciphertext, senderKeyDistributionMessageKey } = await (0, Utils_1.encryptSenderKeyMsgSignalProto)(destinationJid, encodedMsg, meId, authState);
                const senderKeyJids = [];
                // ensure a connection is established with every device
                for (const { user, device, isLid } of devices) {
                    const encodedLid = (0, WABinary_1.jidEncode)(user, isLid ? "lid" : "s.whatsapp.net", device);
                    if (!senderKeyMap[encodedLid]) {
                        senderKeyJids.push(encodedLid);
                        // store that this person has had the sender keys sent to them
                        senderKeyMap[encodedLid] = true;
                    }
                }
                // if there are some participants with whom the session has not been established
                // if there are, we re-send the senderkey
                if (senderKeyJids.length) {
                    logger.debug({ senderKeyJids }, "sending new sender key");
                    const encSenderKeyMsg = (0, Utils_1.encodeWAMessage)({
                        senderKeyDistributionMessage: {
                            axolotlSenderKeyDistributionMessage: senderKeyDistributionMessageKey,
                            groupId: destinationJid
                        }
                    });
                    await assertSessions(senderKeyJids, false);
                    const result = await createParticipantNodes(senderKeyJids, encSenderKeyMsg);
                    shouldIncludeDeviceIdentity =
                        shouldIncludeDeviceIdentity || result.shouldIncludeDeviceIdentity;
                    participants.push(...result.nodes);
                }
                binaryNodeContent.push({
                    tag: "enc",
                    attrs: { v: "2", type: "skmsg" },
                    content: ciphertext
                });
                await authState.keys.set({
                    "sender-key-memory": { [jid]: senderKeyMap }
                });
            }
            else if (!isRetryResend) {
                const { user } = (0, WABinary_1.jidDecode)(destinationJid);
                const meUser = (_a = (0, WABinary_1.jidDecode)(meId)) === null || _a === void 0 ? void 0 : _a.user;
                const encodedMeMsg = (0, Utils_1.encodeWAMessage)({
                    deviceSentMessage: {
                        destinationJid,
                        message
                    }
                });
                if ((additionalAttributes === null || additionalAttributes === void 0 ? void 0 : additionalAttributes["category"]) === "peer" && user === meUser) {
                    devices.push({ user: meUser });
                }
                else {
                    const additionalDevices = await getUSyncDevices([meId, jid], !!useUserDevicesCache, false);
                    devices.push(...additionalDevices);
                }
                const allIds = [];
                const meIds = [];
                const otherIds = [];
                for (const { user, device, isLid } of devices) {
                    const isMe = user === meUser;
                    const encodedLid = (0, WABinary_1.jidEncode)(user, isLid ? "lid" : "s.whatsapp.net", device);
                    if (isMe) {
                        meIds.push(encodedLid);
                    }
                    else {
                        otherIds.push(encodedLid);
                    }
                    allIds.push(encodedLid);
                }
                await assertSessions(allIds, false);
                const [{ nodes: meNodes, shouldIncludeDeviceIdentity: s1 }, { nodes: otherNodes, shouldIncludeDeviceIdentity: s2 }] = await Promise.all([
                    createParticipantNodes(meIds, encodedMeMsg),
                    createParticipantNodes(otherIds, encodedMsg)
                ]);
                participants.push(...meNodes);
                participants.push(...otherNodes);
                shouldIncludeDeviceIdentity = shouldIncludeDeviceIdentity || s1 || s2;
            }
            if (participants.length) {
                if ((additionalAttributes === null || additionalAttributes === void 0 ? void 0 : additionalAttributes["category"]) === "peer") {
                    const peerNode = (_c = (_b = participants[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c[0];
                    if (peerNode) {
                        binaryNodeContent.push(peerNode);
                    }
                }
                else {
                    binaryNodeContent.push({
                        tag: "participants",
                        attrs: {},
                        content: participants
                    });
                }
            }
            if (isRetryResend) {
                // when the retry request is not for a group
                // only send to the specific device that asked for a retry
                // otherwise the message is sent out to every device that should be a recipient
                if (!isGroup && !isStatus) {
                    additionalAttributes = {
                        ...additionalAttributes,
                        device_fanout: "false"
                    };
                }
                await assertSessions([participant.jid], true);
                if (isGroup) {
                    const result = await authState.keys.get("sender-key-memory", [
                        destinationJid
                    ]);
                    const groupSenderKeyMap = result[destinationJid] || {};
                    groupSenderKeyMap[participant.jid] = false;
                    await authState.keys.set({
                        "sender-key-memory": { [destinationJid]: groupSenderKeyMap }
                    });
                }
                const isMe = (0, WABinary_1.areJidsSameUser)(participant.jid, meId);
                const encodedMessageToSend = isMe
                    ? (0, Utils_1.encodeWAMessage)({
                        deviceSentMessage: {
                            destinationJid,
                            message
                        }
                    })
                    : encodedMsg;
                const { type, ciphertext: encryptedContent } = await (0, Utils_1.encryptSignalProto)(participant.jid, encodedMessageToSend, authState);
                binaryNodeContent.push({
                    tag: "enc",
                    attrs: {
                        v: "2",
                        type,
                        count: participant.count.toString()
                    },
                    content: encryptedContent
                });
            }
            const stanza = {
                tag: "message",
                attrs: {
                    id: msgId,
                    type: "text",
                    ...(additionalAttributes || {})
                },
                content: binaryNodeContent
            };
            // if the participant to send to is explicitly specified (generally retry recp)
            // ensure the message is only sent to that person
            // if a retry receipt is sent to everyone -- it'll fail decryption for everyone else who received the msg
            if (participant) {
                if ((0, WABinary_1.isJidGroup)(destinationJid)) {
                    stanza.attrs.to = destinationJid;
                    stanza.attrs.participant = participant.jid;
                }
                else if ((0, WABinary_1.areJidsSameUser)(participant.jid, meId)) {
                    stanza.attrs.to = participant.jid;
                    stanza.attrs.recipient = destinationJid;
                }
                else {
                    stanza.attrs.to = participant.jid;
                }
            }
            else {
                stanza.attrs.to = destinationJid;
            }
            if (shouldIncludeDeviceIdentity) {
                stanza.content.push({
                    tag: "device-identity",
                    attrs: {},
                    content: (0, Utils_1.encodeSignedDeviceIdentity)(authState.creds.account, true)
                });
                logger.debug({ jid }, "adding device identity");
            }
            const contactTcTokenData = !isGroup && !isRetryResend && !isStatus
                ? await authState.keys.get("contacts-tc-token", [destinationJid])
                : {};
            const tcTokenBuffer = (_d = contactTcTokenData[destinationJid]) === null || _d === void 0 ? void 0 : _d.token;
            if (tcTokenBuffer) {
                stanza.content.push({
                    tag: "tctoken",
                    attrs: {},
                    content: tcTokenBuffer
                });
            }
            const innerMessage = ((_e = message.documentWithCaptionMessage) === null || _e === void 0 ? void 0 : _e.message) || message;
            const buttonContent = createButtonNode(innerMessage);
            if (buttonContent) {
                stanza.content.push({
                    tag: "biz",
                    attrs: {},
                    content: buttonContent
                });
                logger.debug({ jid }, `adding biz node for buttons message`);
            }
            logger.debug({ msgId }, `sending message to ${participants.length} devices`);
            await sendNode(stanza);
        });
        return msgId;
    };
    const getPrivacyTokens = async (jids) => {
        const t = (0, Utils_1.unixTimestampSeconds)().toString();
        const result = await query({
            tag: "iq",
            attrs: {
                to: WABinary_1.S_WHATSAPP_NET,
                type: "set",
                xmlns: "privacy"
            },
            content: [
                {
                    tag: "tokens",
                    attrs: {},
                    content: jids.map(jid => ({
                        tag: "token",
                        attrs: {
                            jid: (0, WABinary_1.jidNormalizedUser)(jid),
                            t,
                            type: "trusted_contact"
                        }
                    }))
                }
            ]
        });
        return result;
    };
    const waUploadToServer = (0, Utils_1.getWAUploadToServer)(config, refreshMediaConn);
    const waitForMsgMediaUpdate = (0, Utils_1.bindWaitForEvent)(ev, "messages.media-update");
    return {
        ...sock,
        getPrivacyTokens,
        getUSyncDevices,
        assertSessions,
        relayMessage,
        sendReceipt,
        sendReceipts,
        readMessages,
        refreshMediaConn,
        waUploadToServer,
        fetchPrivacySettings,
        sendPeerDataOperationMessage,
        updateMediaMessage: async (message) => {
            const content = (0, Utils_1.assertMediaContent)(message.message);
            const mediaKey = content.mediaKey;
            const meId = authState.creds.me.id;
            const node = (0, Utils_1.encryptMediaRetryRequest)(message.key, mediaKey, meId);
            let error = undefined;
            await Promise.all([
                sendNode(node),
                waitForMsgMediaUpdate(update => {
                    const result = update.find(c => c.key.id === message.key.id);
                    if (result) {
                        if (result.error) {
                            error = result.error;
                        }
                        else {
                            try {
                                const media = (0, Utils_1.decryptMediaRetryData)(result.media, mediaKey, result.key.id);
                                if (media.result !==
                                    WAProto_1.proto.MediaRetryNotification.ResultType.SUCCESS) {
                                    const resultStr = WAProto_1.proto.MediaRetryNotification.ResultType[media.result];
                                    throw new boom_1.Boom(`Media re-upload failed by device (${resultStr})`, {
                                        data: media,
                                        statusCode: (0, Utils_1.getStatusCodeForMediaRetry)(media.result) || 404
                                    });
                                }
                                content.directPath = media.directPath;
                                content.url = (0, Utils_1.getUrlFromDirectPath)(content.directPath);
                                logger.debug({ directPath: media.directPath, key: result.key }, "media update successful");
                            }
                            catch (err) {
                                error = err;
                            }
                        }
                        return true;
                    }
                })
            ]);
            if (error) {
                throw error;
            }
            ev.emit("messages.update", [
                { key: message.key, update: { message: message.message } }
            ]);
            return message;
        },
        sendMessage: async (jid, content, options = {}) => {
            var _a, _b, _c, _d;
            const userJid = authState.creds.me.id;
            if (typeof content === "object" &&
                "disappearingMessagesInChat" in content &&
                typeof content["disappearingMessagesInChat"] !== "undefined" &&
                (0, WABinary_1.isJidGroup)(jid)) {
                const { disappearingMessagesInChat } = content;
                const value = typeof disappearingMessagesInChat === "boolean"
                    ? disappearingMessagesInChat
                        ? Defaults_1.WA_DEFAULT_EPHEMERAL
                        : 0
                    : disappearingMessagesInChat;
                await groupToggleEphemeral(jid, value);
            }
            else {
                const fullMsg = await (0, Utils_1.generateWAMessage)(jid, content, {
                    logger,
                    userJid,
                    getUrlInfo: text => (0, link_preview_1.getUrlInfo)(text, {
                        thumbnailWidth: linkPreviewImageThumbnailWidth,
                        timeoutMs: 3000,
                        uploadImage: generateHighQualityLinkPreview
                            ? waUploadToServer
                            : undefined
                    }, logger),
                    upload: waUploadToServer,
                    mediaCache: config.mediaCache,
                    messageId: (0, Utils_1.generateMessageIDV2)((_a = sock.user) === null || _a === void 0 ? void 0 : _a.id),
                    ...options
                });
                const isDeleteMsg = "delete" in content && !!content.delete;
                const isEditMsg = "edit" in content && !!content.edit;
                const additionalAttributes = {};
                // required for delete
                if (isDeleteMsg) {
                    // if the chat is a group, and I am not the author, then delete the message as an admin
                    if ((0, WABinary_1.isJidGroup)((_b = content.delete) === null || _b === void 0 ? void 0 : _b.remoteJid) &&
                        !((_c = content.delete) === null || _c === void 0 ? void 0 : _c.fromMe)) {
                        additionalAttributes.edit = "8";
                    }
                    else {
                        additionalAttributes.edit = "7";
                    }
                }
                else if (isEditMsg) {
                    additionalAttributes.edit = "1";
                }
                fullMsg.message = (0, Utils_1.patchMessageForMdIfRequired)(fullMsg.message);
                await relayMessage(jid, fullMsg.message, {
                    messageId: fullMsg.key.id,
                    additionalAttributes
                });
                (_d = config.sentMessagesCache) === null || _d === void 0 ? void 0 : _d.set(fullMsg.key.id, fullMsg.message);
                if (config.emitOwnEvents) {
                    process.nextTick(() => {
                        upsertMessage(fullMsg, "append");
                    });
                }
                return fullMsg;
            }
        }
    };
};
exports.makeMessagesSocket = makeMessagesSocket;
